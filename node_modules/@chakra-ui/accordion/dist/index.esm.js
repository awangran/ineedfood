// ../../react-shim.js
import React from "react";

// src/accordion.tsx
import {
  chakra,
  forwardRef,
  omitThemingProps,
  useMultiStyleConfig
} from "@chakra-ui/system";
import { cx, __DEV__ } from "@chakra-ui/utils";
import { useMemo } from "react";

// src/accordion-context.ts
import { createDescendantContext } from "@chakra-ui/descendant";
import { createContext } from "@chakra-ui/react-utils";
var [AccordionStylesProvider, useAccordionStyles] = createContext({
  name: `AccordionStylesContext`,
  errorMessage: `useAccordionStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Accordion />" `
});
var [AccordionItemProvider, useAccordionItemContext] = createContext({
  name: "AccordionItemContext",
  errorMessage: "useAccordionItemContext: `context` is undefined. Seems you forgot to wrap the accordion item parts in `<AccordionItem />` "
});
var [
  AccordionDescendantsProvider,
  useAccordionDescendantsContext,
  useAccordionDescendants,
  useAccordionDescendant
] = createDescendantContext();

// src/use-accordion.ts
import {
  useControllableState,
  useIds,
  useUnmountEffect
} from "@chakra-ui/hooks";
import {
  createContext as createContext2,
  mergeRefs
} from "@chakra-ui/react-utils";
import {
  addItem,
  callAllHandlers,
  focus,
  isArray,
  isUndefined,
  normalizeEventKey,
  removeItem,
  warn
} from "@chakra-ui/utils";
import { useCallback, useRef, useState } from "react";
function useAccordion(props) {
  const {
    onChange,
    defaultIndex,
    index: indexProp,
    allowMultiple,
    allowToggle,
    ...htmlProps
  } = props;
  allowMultipleWarning(props);
  allowMultipleAndAllowToggleWarning(props);
  const descendants = useAccordionDescendants();
  const [focusedIndex, setFocusedIndex] = useState(-1);
  useUnmountEffect(() => {
    setFocusedIndex(-1);
  });
  const [index, setIndex] = useControllableState({
    value: indexProp,
    defaultValue() {
      if (allowMultiple)
        return defaultIndex ?? [];
      return defaultIndex ?? -1;
    },
    onChange
  });
  const getAccordionItemProps = (idx) => {
    let isOpen = false;
    if (idx !== null) {
      isOpen = isArray(index) ? index.includes(idx) : index === idx;
    }
    const onChange2 = (isOpen2) => {
      if (idx === null)
        return;
      if (allowMultiple && isArray(index)) {
        const nextState = isOpen2 ? addItem(index, idx) : removeItem(index, idx);
        setIndex(nextState);
      } else if (isOpen2) {
        setIndex(idx);
      } else if (allowToggle) {
        setIndex(-1);
      }
    };
    return { isOpen, onChange: onChange2 };
  };
  return {
    index,
    setIndex,
    htmlProps,
    getAccordionItemProps,
    focusedIndex,
    setFocusedIndex,
    descendants
  };
}
var [AccordionProvider, useAccordionContext] = createContext2({
  name: "AccordionContext",
  errorMessage: "useAccordionContext: `context` is undefined. Seems you forgot to wrap the accordion components in `<Accordion />`"
});
function useAccordionItem(props) {
  const { isDisabled, isFocusable, id, ...htmlProps } = props;
  const { getAccordionItemProps, setFocusedIndex } = useAccordionContext();
  const buttonRef = useRef(null);
  const [buttonId, panelId] = useIds(id, `accordion-button`, `accordion-panel`);
  focusableNotDisabledWarning(props);
  const { register, index, descendants } = useAccordionDescendant({
    disabled: isDisabled && !isFocusable
  });
  const { isOpen, onChange } = getAccordionItemProps(index === -1 ? null : index);
  warnIfOpenAndDisabled({ isOpen, isDisabled });
  const onOpen = () => {
    onChange == null ? void 0 : onChange(true);
  };
  const onClose = () => {
    onChange == null ? void 0 : onChange(false);
  };
  const onClick = useCallback(() => {
    onChange == null ? void 0 : onChange(!isOpen);
    setFocusedIndex(index);
  }, [index, setFocusedIndex, isOpen, onChange]);
  const onKeyDown = useCallback((event) => {
    const eventKey = normalizeEventKey(event);
    const keyMap = {
      ArrowDown: () => {
        const next = descendants.nextEnabled(index);
        if (next)
          focus(next.node);
      },
      ArrowUp: () => {
        const prev = descendants.prevEnabled(index);
        if (prev)
          focus(prev.node);
      },
      Home: () => {
        const first = descendants.firstEnabled();
        if (first)
          focus(first.node);
      },
      End: () => {
        const last = descendants.lastEnabled();
        if (last)
          focus(last.node);
      }
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [descendants, index]);
  const onFocus = useCallback(() => {
    setFocusedIndex(index);
  }, [setFocusedIndex, index]);
  const getButtonProps = useCallback((props2 = {}, ref = null) => ({
    ...props2,
    type: "button",
    ref: mergeRefs(register, buttonRef, ref),
    id: buttonId,
    disabled: !!isDisabled,
    "aria-expanded": !!isOpen,
    "aria-controls": panelId,
    onClick: callAllHandlers(props2.onClick, onClick),
    onFocus: callAllHandlers(props2.onFocus, onFocus),
    onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown)
  }), [
    buttonId,
    isDisabled,
    isOpen,
    onClick,
    onFocus,
    onKeyDown,
    panelId,
    register
  ]);
  const getPanelProps = useCallback((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    role: "region",
    id: panelId,
    "aria-labelledby": buttonId,
    hidden: !isOpen
  }), [buttonId, isOpen, panelId]);
  return {
    isOpen,
    isDisabled,
    isFocusable,
    onOpen,
    onClose,
    getButtonProps,
    getPanelProps,
    htmlProps
  };
}
function allowMultipleWarning(props) {
  const index = props.index || props.defaultIndex;
  const condition = !isUndefined(index) && !isArray(index) && props.allowMultiple;
  warn({
    condition: !!condition,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`
  });
}
function allowMultipleAndAllowToggleWarning(props) {
  warn({
    condition: !!(props.allowMultiple && props.allowToggle),
    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`
  });
}
function focusableNotDisabledWarning(props) {
  warn({
    condition: !!(props.isFocusable && !props.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}
function warnIfOpenAndDisabled(props) {
  warn({
    condition: props.isOpen && !!props.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}

// src/accordion.tsx
var Accordion = forwardRef(function Accordion2({ children, reduceMotion, ...props }, ref) {
  const styles = useMultiStyleConfig("Accordion", props);
  const ownProps = omitThemingProps(props);
  const { htmlProps, descendants, ...context } = useAccordion(ownProps);
  const ctx = useMemo(() => ({ ...context, reduceMotion: !!reduceMotion }), [context, reduceMotion]);
  return /* @__PURE__ */ React.createElement(AccordionDescendantsProvider, {
    value: descendants
  }, /* @__PURE__ */ React.createElement(AccordionProvider, {
    value: ctx
  }, /* @__PURE__ */ React.createElement(AccordionStylesProvider, {
    value: styles
  }, /* @__PURE__ */ React.createElement(chakra.div, {
    ref,
    ...htmlProps,
    className: cx("chakra-accordion", props.className),
    __css: styles.root
  }, children))));
});
if (__DEV__) {
  Accordion.displayName = "Accordion";
}

// src/accordion-button.tsx
import {
  chakra as chakra2,
  forwardRef as forwardRef2
} from "@chakra-ui/system";
import { cx as cx2, __DEV__ as __DEV__2 } from "@chakra-ui/utils";
var AccordionButton = forwardRef2(function AccordionButton2(props, ref) {
  const { getButtonProps } = useAccordionItemContext();
  const buttonProps = getButtonProps(props, ref);
  const styles = useAccordionStyles();
  const buttonStyles = {
    display: "flex",
    alignItems: "center",
    width: "100%",
    outline: 0,
    ...styles.button
  };
  return /* @__PURE__ */ React.createElement(chakra2.button, {
    ...buttonProps,
    className: cx2("chakra-accordion__button", props.className),
    __css: buttonStyles
  });
});
if (__DEV__2) {
  AccordionButton.displayName = "AccordionButton";
}

// src/accordion-icon.tsx
import { Icon } from "@chakra-ui/icon";
import { cx as cx3, __DEV__ as __DEV__3 } from "@chakra-ui/utils";
function AccordionIcon(props) {
  const { isOpen, isDisabled } = useAccordionItemContext();
  const { reduceMotion } = useAccordionContext();
  const _className = cx3("chakra-accordion__icon", props.className);
  const styles = useAccordionStyles();
  const iconStyles = {
    opacity: isDisabled ? 0.4 : 1,
    transform: isOpen ? "rotate(-180deg)" : void 0,
    transition: reduceMotion ? void 0 : "transform 0.2s",
    transformOrigin: "center",
    ...styles.icon
  };
  return /* @__PURE__ */ React.createElement(Icon, {
    viewBox: "0 0 24 24",
    "aria-hidden": true,
    className: _className,
    __css: iconStyles,
    ...props
  }, /* @__PURE__ */ React.createElement("path", {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }));
}
if (__DEV__3) {
  AccordionIcon.displayName = "AccordionIcon";
}

// src/accordion-item.tsx
import {
  chakra as chakra3,
  forwardRef as forwardRef3
} from "@chakra-ui/system";
import { cx as cx4, runIfFn, __DEV__ as __DEV__4 } from "@chakra-ui/utils";
import { useMemo as useMemo2 } from "react";
var AccordionItem = forwardRef3(function AccordionItem2(props, ref) {
  const { children, className } = props;
  const { htmlProps, ...context } = useAccordionItem(props);
  const styles = useAccordionStyles();
  const containerStyles = {
    ...styles.container,
    overflowAnchor: "none"
  };
  const ctx = useMemo2(() => context, [context]);
  return /* @__PURE__ */ React.createElement(AccordionItemProvider, {
    value: ctx
  }, /* @__PURE__ */ React.createElement(chakra3.div, {
    ref,
    ...htmlProps,
    className: cx4("chakra-accordion__item", className),
    __css: containerStyles
  }, runIfFn(children, {
    isExpanded: !!context.isOpen,
    isDisabled: !!context.isDisabled
  })));
});
if (__DEV__4) {
  AccordionItem.displayName = "AccordionItem";
}
function useAccordionItemState() {
  const { isOpen, isDisabled, onClose, onOpen } = useAccordionItemContext();
  return { isOpen, onClose, isDisabled, onOpen };
}

// src/accordion-panel.tsx
import { chakra as chakra4, forwardRef as forwardRef4 } from "@chakra-ui/system";
import { Collapse } from "@chakra-ui/transition";
import { cx as cx5, __DEV__ as __DEV__5 } from "@chakra-ui/utils";
var AccordionPanel = forwardRef4(function AccordionPanel2(props, ref) {
  const { reduceMotion } = useAccordionContext();
  const { getPanelProps, isOpen } = useAccordionItemContext();
  const panelProps = getPanelProps(props, ref);
  const _className = cx5("chakra-accordion__panel", props.className);
  const styles = useAccordionStyles();
  if (!reduceMotion) {
    delete panelProps.hidden;
  }
  const child = /* @__PURE__ */ React.createElement(chakra4.div, {
    ...panelProps,
    __css: styles.panel,
    className: _className
  });
  if (!reduceMotion) {
    return /* @__PURE__ */ React.createElement(Collapse, {
      in: isOpen
    }, child);
  }
  return child;
});
if (__DEV__5) {
  AccordionPanel.displayName = "AccordionPanel";
}
export {
  Accordion,
  AccordionButton,
  AccordionIcon,
  AccordionItem,
  AccordionPanel,
  AccordionProvider,
  useAccordion,
  useAccordionContext,
  useAccordionItem,
  useAccordionItemState,
  useAccordionStyles
};
