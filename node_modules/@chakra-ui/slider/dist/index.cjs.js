"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  RangeSlider: () => RangeSlider,
  RangeSliderFilledTrack: () => RangeSliderFilledTrack,
  RangeSliderMark: () => RangeSliderMark,
  RangeSliderProvider: () => RangeSliderProvider,
  RangeSliderThumb: () => RangeSliderThumb,
  RangeSliderTrack: () => RangeSliderTrack,
  Slider: () => Slider,
  SliderFilledTrack: () => SliderFilledTrack,
  SliderMark: () => SliderMark,
  SliderProvider: () => SliderProvider,
  SliderThumb: () => SliderThumb,
  SliderTrack: () => SliderTrack,
  useRangeSlider: () => useRangeSlider,
  useRangeSliderContext: () => useRangeSliderContext,
  useRangeSliderStyles: () => useRangeSliderStyles,
  useSlider: () => useSlider,
  useSliderContext: () => useSliderContext,
  useSliderStyles: () => useSliderStyles
});
module.exports = __toCommonJS(src_exports);

// ../../react-shim.js
var import_react = __toESM(require("react"));

// src/range-slider.tsx
var import_react_utils2 = require("@chakra-ui/react-utils");
var import_system = require("@chakra-ui/system");
var import_utils2 = require("@chakra-ui/utils");
var import_react3 = require("react");

// src/use-range-slider.ts
var import_hooks = require("@chakra-ui/hooks");
var import_react_utils = require("@chakra-ui/react-utils");
var import_utils = require("@chakra-ui/utils");
var import_react2 = require("react");

// src/slider-utils.ts
function getIds(id) {
  return {
    root: `slider-root-${id}`,
    getThumb: (i) => `slider-thumb-${id}-${i}`,
    getInput: (i) => `slider-input-${id}-${i}`,
    track: `slider-track-${id}`,
    innerTrack: `slider-filled-track-${id}`,
    getMarker: (i) => `slider-marker-${id}-${i}`,
    output: `slider-output-${id}`
  };
}
function orient(options) {
  const { orientation, vertical, horizontal } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
var zeroRect = { width: 0, height: 0 };
function getStyles(options) {
  const { orientation, thumbPercents, thumbRects, isReversed } = options;
  const getThumbStyle = (i) => ({
    position: "absolute",
    userSelect: "none",
    WebkitUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    touchAction: "none",
    ...orient({
      orientation,
      vertical: {
        bottom: `calc(${thumbPercents[i]}% - ${thumbRects[i].height / 2}px)`
      },
      horizontal: {
        left: `calc(${thumbPercents[i]}% - ${thumbRects[i].width / 2}px)`
      }
    })
  });
  const size = orientation === "vertical" ? thumbRects.reduce((a, b) => a.height > b.height ? a : b, zeroRect) : thumbRects.reduce((a, b) => a.width > b.width ? a : b, zeroRect);
  const rootStyle = {
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0,
    ...orient({
      orientation,
      vertical: {
        paddingLeft: size.width / 2,
        paddingRight: size.width / 2
      },
      horizontal: {
        paddingTop: size.height / 2,
        paddingBottom: size.height / 2
      }
    })
  };
  const trackStyle = {
    position: "absolute",
    ...orient({
      orientation,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        height: "100%"
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        width: "100%"
      }
    })
  };
  const isSingleThumb = thumbPercents.length === 1;
  const fallback = [0, isReversed ? 100 - thumbPercents[0] : thumbPercents[0]];
  const range = isSingleThumb ? fallback : thumbPercents;
  let start = range[0];
  if (!isSingleThumb && isReversed) {
    start = 100 - start;
  }
  const percent = Math.abs(range[range.length - 1] - range[0]);
  const innerTrackStyle = {
    ...trackStyle,
    ...orient({
      orientation,
      vertical: isReversed ? { height: `${percent}%`, top: `${start}%` } : { height: `${percent}%`, bottom: `${start}%` },
      horizontal: isReversed ? { width: `${percent}%`, right: `${start}%` } : { width: `${percent}%`, left: `${start}%` }
    })
  };
  return { trackStyle, innerTrackStyle, rootStyle, getThumbStyle };
}
function getIsReversed(options) {
  const { isReversed, direction, orientation } = options;
  if (direction === "ltr" || orientation === "vertical") {
    return isReversed;
  }
  return !isReversed;
}

// src/use-range-slider.ts
function useRangeSlider(props) {
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    minStepsBetweenThumbs = 0,
    ...htmlProps
  } = props;
  const onChangeStart = (0, import_hooks.useCallbackRef)(onChangeStartProp);
  const onChangeEnd = (0, import_hooks.useCallbackRef)(onChangeEndProp);
  const getAriaValueText = (0, import_hooks.useCallbackRef)(getAriaValueTextProp);
  const isReversed = getIsReversed({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  const [valueState, setValue] = (0, import_hooks.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue ?? [25, 75],
    onChange
  });
  if (!Array.isArray(valueState)) {
    throw new TypeError(`[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof valueState}\``);
  }
  const [isDragging, setDragging] = (0, import_hooks.useBoolean)();
  const [isFocused, setFocused] = (0, import_hooks.useBoolean)();
  const [activeIndex, setActiveIndex] = (0, import_react2.useState)(-1);
  const eventSourceRef = (0, import_react2.useRef)(null);
  const isInteractive = !(isDisabled || isReadOnly);
  const initialValue = (0, import_react2.useRef)(valueState);
  const value = valueState.map((val) => (0, import_utils.clampValue)(val, min, max));
  const valueRef = (0, import_hooks.useLatestRef)(value);
  const spacing = minStepsBetweenThumbs * step;
  const valueBounds = getValueBounds(value, min, max, spacing);
  const reversedValue = value.map((val) => max - val + min);
  const thumbValues = isReversed ? reversedValue : value;
  const thumbPercents = thumbValues.map((val) => (0, import_utils.valueToPercent)(val, min, max));
  const isVertical = orientation === "vertical";
  const [thumbRects, setThumbRects] = (0, import_react2.useState)(Array.from({ length: value.length }).map(() => ({ width: 0, height: 0 })));
  (0, import_react2.useEffect)(() => {
    var _a;
    if (!rootRef.current)
      return;
    const thumbs = Array.from((_a = rootRef.current) == null ? void 0 : _a.querySelectorAll("[role=slider]"));
    const rects = thumbs.map((el) => ({
      width: el.offsetWidth,
      height: el.offsetHeight
    }));
    if (rects.length)
      setThumbRects(rects);
  }, []);
  const trackRef = (0, import_react2.useRef)(null);
  const rootRef = (0, import_react2.useRef)(null);
  const uuid = (0, import_hooks.useId)(idProp);
  const ids = getIds(uuid);
  const getValueFromPointer = (0, import_react2.useCallback)((event) => {
    var _a;
    if (!trackRef.current)
      return;
    eventSourceRef.current = "pointer";
    const rect = trackRef.current.getBoundingClientRect();
    const { clientX, clientY } = ((_a = event.touches) == null ? void 0 : _a[0]) ?? event;
    const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;
    const length = isVertical ? rect.height : rect.width;
    let percent = diff / length;
    if (isReversed)
      percent = 1 - percent;
    return (0, import_utils.percentToValue)(percent, min, max);
  }, [isVertical, isReversed, max, min]);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const actions = (0, import_react2.useMemo)(() => ({
    setValueAtIndex: (index, val) => {
      if (!isInteractive)
        return;
      const bounds = valueBounds[index];
      val = parseFloat((0, import_utils.roundValueToStep)(val, bounds.min, oneStep));
      val = (0, import_utils.clampValue)(val, bounds.min, bounds.max);
      const next = [...value];
      next[index] = val;
      setValue(next);
    },
    setActiveIndex,
    stepUp: (index, step2 = oneStep) => {
      const valueAtIndex = value[index];
      const next = isReversed ? valueAtIndex - step2 : valueAtIndex + step2;
      actions.setValueAtIndex(index, next);
    },
    stepDown: (index, step2 = oneStep) => {
      const valueAtIndex = value[index];
      const next = isReversed ? valueAtIndex + step2 : valueAtIndex - step2;
      actions.setValueAtIndex(index, next);
    },
    reset: () => setValue(initialValue.current)
  }), [oneStep, value, isReversed, setValue, isInteractive, valueBounds]);
  const onKeyDown = (0, import_react2.useCallback)((event) => {
    const eventKey = (0, import_utils.normalizeEventKey)(event);
    const keyMap = {
      ArrowRight: () => actions.stepUp(activeIndex),
      ArrowUp: () => actions.stepUp(activeIndex),
      ArrowLeft: () => actions.stepDown(activeIndex),
      ArrowDown: () => actions.stepDown(activeIndex),
      PageUp: () => actions.stepUp(activeIndex, tenSteps),
      PageDown: () => actions.stepDown(activeIndex, tenSteps),
      Home: () => {
        const { min: value2 } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value2);
      },
      End: () => {
        const { max: value2 } = valueBounds[activeIndex];
        actions.setValueAtIndex(activeIndex, value2);
      }
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      eventSourceRef.current = "keyboard";
    }
  }, [actions, activeIndex, tenSteps, valueBounds]);
  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = (0, import_react2.useMemo)(() => getStyles({
    isReversed,
    orientation,
    thumbRects,
    thumbPercents
  }), [isReversed, orientation, thumbPercents, thumbRects]);
  const focusThumb = (0, import_react2.useCallback)((index) => {
    var _a;
    const idx = index ?? activeIndex;
    if (idx !== -1 && focusThumbOnChange) {
      const id = ids.getThumb(idx);
      const thumb = (_a = rootRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id);
      if (thumb) {
        setTimeout(() => (0, import_utils.focus)(thumb));
      }
    }
  }, [focusThumbOnChange, activeIndex, ids]);
  (0, import_hooks.useUpdateEffect)(() => {
    if (eventSourceRef.current === "keyboard") {
      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);
    }
  }, [value, onChangeEnd]);
  const onPanSessionStart = (event) => {
    const pointValue = getValueFromPointer(event) || 0;
    const distances = value.map((val) => Math.abs(val - pointValue));
    const closest = Math.min(...distances);
    let index = distances.indexOf(closest);
    const thumbsAtPosition = distances.filter((distance) => distance === closest);
    const isThumbStacked = thumbsAtPosition.length > 1;
    if (isThumbStacked && pointValue > value[index]) {
      index = index + thumbsAtPosition.length - 1;
    }
    setActiveIndex(index);
    actions.setValueAtIndex(index, pointValue);
    focusThumb(index);
  };
  const onPan = (event) => {
    if (activeIndex == -1)
      return;
    const pointValue = getValueFromPointer(event) || 0;
    setActiveIndex(activeIndex);
    actions.setValueAtIndex(activeIndex, pointValue);
    focusThumb(activeIndex);
  };
  (0, import_hooks.usePanGesture)(rootRef, {
    onPanSessionStart(event) {
      if (!isInteractive)
        return;
      setDragging.on();
      onPanSessionStart(event);
      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);
    },
    onPanSessionEnd() {
      if (!isInteractive)
        return;
      setDragging.off();
      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);
    },
    onPan(event) {
      if (!isInteractive)
        return;
      onPan(event);
    }
  });
  const getRootProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ...htmlProps,
    id: ids.root,
    ref: (0, import_react_utils.mergeRefs)(ref, rootRef),
    tabIndex: -1,
    "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
    "data-focused": (0, import_utils.dataAttr)(isFocused),
    style: { ...props2.style, ...rootStyle }
  }), [htmlProps, isDisabled, isFocused, rootStyle, ids]);
  const getTrackProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, import_react_utils.mergeRefs)(ref, trackRef),
    id: ids.track,
    "data-disabled": (0, import_utils.dataAttr)(isDisabled),
    style: { ...props2.style, ...trackStyle }
  }), [isDisabled, trackStyle, ids]);
  const getInnerTrackProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    id: ids.innerTrack,
    style: { ...props2.style, ...innerTrackStyle }
  }), [innerTrackStyle, ids]);
  const getThumbProps = (0, import_react2.useCallback)((props2, ref = null) => {
    const { index, ...rest } = props2;
    const _value = value[index];
    if (_value == null) {
      throw new TypeError(`[range-slider > thumb] Cannot find value at index \`${index}\`. The \`value\` or \`defaultValue\` length is : ${value.length}`);
    }
    const bounds = valueBounds[index];
    return {
      ...rest,
      ref,
      role: "slider",
      tabIndex: isInteractive ? 0 : void 0,
      id: ids.getThumb(index),
      "data-active": (0, import_utils.dataAttr)(isDragging && activeIndex === index),
      "aria-valuetext": (getAriaValueText == null ? void 0 : getAriaValueText(_value)) ?? (ariaValueText == null ? void 0 : ariaValueText[index]),
      "aria-valuemin": bounds.min,
      "aria-valuemax": bounds.max,
      "aria-valuenow": _value,
      "aria-orientation": orientation,
      "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
      "aria-readonly": (0, import_utils.ariaAttr)(isReadOnly),
      "aria-label": ariaLabel == null ? void 0 : ariaLabel[index],
      "aria-labelledby": (ariaLabel == null ? void 0 : ariaLabel[index]) ? void 0 : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],
      style: { ...props2.style, ...getThumbStyle(index) },
      onKeyDown: (0, import_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
      onFocus: (0, import_utils.callAllHandlers)(props2.onFocus, () => {
        setFocused.on();
        setActiveIndex(index);
      }),
      onBlur: (0, import_utils.callAllHandlers)(props2.onBlur, () => {
        setFocused.off();
        setActiveIndex(-1);
      })
    };
  }, [
    ids,
    value,
    valueBounds,
    isInteractive,
    isDragging,
    activeIndex,
    getAriaValueText,
    ariaValueText,
    orientation,
    isDisabled,
    isReadOnly,
    ariaLabel,
    ariaLabelledBy,
    getThumbStyle,
    onKeyDown,
    setFocused
  ]);
  const getOutputProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    id: ids.output,
    htmlFor: value.map((v, i) => ids.getThumb(i)).join(" "),
    "aria-live": "off"
  }), [ids, value]);
  const getMarkerProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => {
    const { value: v, ...rest } = props2;
    const isInRange = !(v < min || v > max);
    const isHighlighted = v >= value[0] && v <= value[value.length - 1];
    let percent = (0, import_utils.valueToPercent)(v, min, max);
    percent = isReversed ? 100 - percent : percent;
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...orient({
        orientation,
        vertical: { bottom: `${percent}%` },
        horizontal: { left: `${percent}%` }
      })
    };
    return {
      ...rest,
      ref,
      id: ids.getMarker(props2.value),
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": (0, import_utils.dataAttr)(isDisabled),
      "data-invalid": (0, import_utils.dataAttr)(!isInRange),
      "data-highlighted": (0, import_utils.dataAttr)(isHighlighted),
      style: {
        ...props2.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value, ids]);
  const getInputProps = (0, import_react2.useCallback)((props2, ref = null) => {
    const { index, ...rest } = props2;
    return {
      ...rest,
      ref,
      id: ids.getInput(index),
      type: "hidden",
      value: value[index],
      name: Array.isArray(name) ? name[index] : `${name}-${index}`
    };
  }, [name, value, ids]);
  return {
    state: {
      value,
      isFocused,
      isDragging,
      getThumbPercent: (i) => thumbPercents[i],
      getThumbMinValue: (i) => valueBounds[i].min,
      getThumbMaxValue: (i) => valueBounds[i].max
    },
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps,
    getOutputProps
  };
}
var getValueBounds = (arr, min, max, spacing) => arr.map((v, i) => {
  const _min = i === 0 ? min : arr[i - 1] + spacing;
  const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;
  return { min: _min, max: _max };
});

// src/range-slider.tsx
var [RangeSliderProvider, useRangeSliderContext] = (0, import_react_utils2.createContext)({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
});
var [RangeSliderStylesProvider, useRangeSliderStyles] = (0, import_react_utils2.createContext)({
  name: `RangeSliderStylesContext`,
  errorMessage: `useRangeSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
});
var RangeSlider = (0, import_system.forwardRef)(function RangeSlider2(props, ref) {
  const styles = (0, import_system.useMultiStyleConfig)("Slider", props);
  const ownProps = (0, import_system.omitThemingProps)(props);
  const { direction } = (0, import_system.useTheme)();
  ownProps.direction = direction;
  const { getRootProps, ...context } = useRangeSlider(ownProps);
  const ctx = (0, import_react3.useMemo)(() => ({ ...context, name: props.name }), [context, props.name]);
  return /* @__PURE__ */ import_react.default.createElement(RangeSliderProvider, {
    value: ctx
  }, /* @__PURE__ */ import_react.default.createElement(RangeSliderStylesProvider, {
    value: styles
  }, /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ...getRootProps({}, ref),
    className: "chakra-slider",
    __css: styles.container
  }, props.children)));
});
RangeSlider.defaultProps = {
  orientation: "horizontal"
};
if (import_utils2.__DEV__) {
  RangeSlider.displayName = "RangeSlider";
}
var RangeSliderThumb = (0, import_system.forwardRef)(function RangeSliderThumb2(props, ref) {
  const { getThumbProps, getInputProps, name } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const thumbProps = getThumbProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ...thumbProps,
    className: (0, import_utils2.cx)("chakra-slider__thumb", props.className),
    __css: styles.thumb
  }, thumbProps.children, name && /* @__PURE__ */ import_react.default.createElement("input", {
    ...getInputProps({ index: props.index })
  }));
});
if (import_utils2.__DEV__) {
  RangeSliderThumb.displayName = "RangeSliderThumb";
}
var RangeSliderTrack = (0, import_system.forwardRef)(function RangeSliderTrack2(props, ref) {
  const { getTrackProps } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const trackProps = getTrackProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ...trackProps,
    className: (0, import_utils2.cx)("chakra-slider__track", props.className),
    __css: styles.track,
    "data-testid": "chakra-range-slider-track"
  });
});
if (import_utils2.__DEV__) {
  RangeSliderTrack.displayName = "RangeSliderTrack";
}
var RangeSliderFilledTrack = (0, import_system.forwardRef)(function RangeSliderFilledTrack2(props, ref) {
  const { getInnerTrackProps } = useRangeSliderContext();
  const styles = useRangeSliderStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ...trackProps,
    className: "chakra-slider__filled-track",
    __css: styles.filledTrack
  });
});
if (import_utils2.__DEV__) {
  RangeSliderFilledTrack.displayName = "RangeSliderFilledTrack";
}
var RangeSliderMark = (0, import_system.forwardRef)(function RangeSliderMark2(props, ref) {
  const { getMarkerProps } = useRangeSliderContext();
  const markProps = getMarkerProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ...markProps,
    className: (0, import_utils2.cx)("chakra-slider__marker", props.className)
  });
});
if (import_utils2.__DEV__) {
  RangeSliderMark.displayName = "RangeSliderMark";
}

// src/slider.tsx
var import_react_utils4 = require("@chakra-ui/react-utils");
var import_system2 = require("@chakra-ui/system");
var import_utils4 = require("@chakra-ui/utils");

// src/use-slider.ts
var import_hooks2 = require("@chakra-ui/hooks");
var import_react_utils3 = require("@chakra-ui/react-utils");
var import_utils3 = require("@chakra-ui/utils");
var import_react4 = require("react");
function useSlider(props) {
  const {
    min = 0,
    max = 100,
    onChange,
    value: valueProp,
    defaultValue,
    isReversed: isReversedProp,
    direction = "ltr",
    orientation = "horizontal",
    id: idProp,
    isDisabled,
    isReadOnly,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    step = 1,
    getAriaValueText: getAriaValueTextProp,
    "aria-valuetext": ariaValueText,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    name,
    focusThumbOnChange = true,
    ...htmlProps
  } = props;
  const onChangeStart = (0, import_hooks2.useCallbackRef)(onChangeStartProp);
  const onChangeEnd = (0, import_hooks2.useCallbackRef)(onChangeEndProp);
  const getAriaValueText = (0, import_hooks2.useCallbackRef)(getAriaValueTextProp);
  const isReversed = getIsReversed({
    isReversed: isReversedProp,
    direction,
    orientation
  });
  const [computedValue, setValue] = (0, import_hooks2.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue ?? getDefaultValue(min, max),
    onChange
  });
  const [isDragging, setDragging] = (0, import_hooks2.useBoolean)();
  const [isFocused, setFocused] = (0, import_hooks2.useBoolean)();
  const eventSourceRef = (0, import_react4.useRef)(null);
  const isInteractive = !(isDisabled || isReadOnly);
  const value = (0, import_utils3.clampValue)(computedValue, min, max);
  const valueRef = (0, import_hooks2.useLatestRef)(value);
  const prevRef = (0, import_react4.useRef)(valueRef.current);
  const reversedValue = max - value + min;
  const trackValue = isReversed ? reversedValue : value;
  const thumbPercent = (0, import_utils3.valueToPercent)(trackValue, min, max);
  const isVertical = orientation === "vertical";
  const trackRef = (0, import_react4.useRef)(null);
  const thumbRef = (0, import_react4.useRef)(null);
  const rootRef = (0, import_react4.useRef)(null);
  const [thumbId, trackId] = (0, import_hooks2.useIds)(idProp, `slider-thumb`, `slider-track`);
  const getValueFromPointer = (0, import_react4.useCallback)((event) => {
    var _a;
    if (!trackRef.current)
      return;
    eventSourceRef.current = "pointer";
    const trackRect = (0, import_utils3.getBox)(trackRef.current).borderBox;
    const { clientX, clientY } = ((_a = event.touches) == null ? void 0 : _a[0]) ?? event;
    const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;
    const length = isVertical ? trackRect.height : trackRect.width;
    let percent = diff / length;
    if (isReversed) {
      percent = 1 - percent;
    }
    let nextValue = (0, import_utils3.percentToValue)(percent, min, max);
    if (step) {
      nextValue = parseFloat((0, import_utils3.roundValueToStep)(nextValue, min, step));
    }
    nextValue = (0, import_utils3.clampValue)(nextValue, min, max);
    return nextValue;
  }, [isVertical, isReversed, max, min, step]);
  const tenSteps = (max - min) / 10;
  const oneStep = step || (max - min) / 100;
  const constrain = (0, import_react4.useCallback)((value2) => {
    if (!isInteractive)
      return;
    value2 = parseFloat((0, import_utils3.roundValueToStep)(value2, min, oneStep));
    value2 = (0, import_utils3.clampValue)(value2, min, max);
    setValue(value2);
  }, [oneStep, max, min, setValue, isInteractive]);
  const actions = (0, import_react4.useMemo)(() => ({
    stepUp: (step2 = oneStep) => {
      const next = isReversed ? value - step2 : value + step2;
      constrain(next);
    },
    stepDown: (step2 = oneStep) => {
      const next = isReversed ? value + step2 : value - step2;
      constrain(next);
    },
    reset: () => constrain(defaultValue || 0),
    stepTo: (value2) => constrain(value2)
  }), [constrain, isReversed, value, oneStep, defaultValue]);
  const onKeyDown = (0, import_react4.useCallback)((event) => {
    const eventKey = (0, import_utils3.normalizeEventKey)(event);
    const keyMap = {
      ArrowRight: () => actions.stepUp(),
      ArrowUp: () => actions.stepUp(),
      ArrowLeft: () => actions.stepDown(),
      ArrowDown: () => actions.stepDown(),
      PageUp: () => actions.stepUp(tenSteps),
      PageDown: () => actions.stepDown(tenSteps),
      Home: () => constrain(min),
      End: () => constrain(max)
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
      eventSourceRef.current = "keyboard";
    }
  }, [actions, constrain, max, min, tenSteps]);
  const valueText = (getAriaValueText == null ? void 0 : getAriaValueText(value)) ?? ariaValueText;
  const thumbBoxModel = (0, import_hooks2.useDimensions)(thumbRef);
  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = (0, import_react4.useMemo)(() => {
    const thumbRect = (thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) ?? { width: 0, height: 0 };
    return getStyles({
      isReversed,
      orientation,
      thumbRects: [thumbRect],
      thumbPercents: [thumbPercent]
    });
  }, [isReversed, orientation, thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox, thumbPercent]);
  const focusThumb = (0, import_react4.useCallback)(() => {
    if (thumbRef.current && focusThumbOnChange) {
      setTimeout(() => (0, import_utils3.focus)(thumbRef.current));
    }
  }, [focusThumbOnChange]);
  (0, import_hooks2.useUpdateEffect)(() => {
    focusThumb();
    if (eventSourceRef.current === "keyboard") {
      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);
    }
  }, [value, onChangeEnd]);
  const setValueFromPointer = (event) => {
    const nextValue = getValueFromPointer(event);
    if (nextValue != null && nextValue !== valueRef.current) {
      setValue(nextValue);
    }
  };
  (0, import_hooks2.usePanGesture)(rootRef, {
    onPanSessionStart(event) {
      if (!isInteractive)
        return;
      setDragging.on();
      focusThumb();
      setValueFromPointer(event);
      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);
    },
    onPanSessionEnd() {
      if (!isInteractive)
        return;
      setDragging.off();
      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);
      prevRef.current = valueRef.current;
    },
    onPan(event) {
      if (!isInteractive)
        return;
      setValueFromPointer(event);
    }
  });
  const getRootProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ...htmlProps,
    ref: (0, import_react_utils3.mergeRefs)(ref, rootRef),
    tabIndex: -1,
    "aria-disabled": (0, import_utils3.ariaAttr)(isDisabled),
    "data-focused": (0, import_utils3.dataAttr)(isFocused),
    style: {
      ...props2.style,
      ...rootStyle
    }
  }), [htmlProps, isDisabled, isFocused, rootStyle]);
  const getTrackProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, import_react_utils3.mergeRefs)(ref, trackRef),
    id: trackId,
    "data-disabled": (0, import_utils3.dataAttr)(isDisabled),
    style: {
      ...props2.style,
      ...trackStyle
    }
  }), [isDisabled, trackId, trackStyle]);
  const getInnerTrackProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    style: {
      ...props2.style,
      ...innerTrackStyle
    }
  }), [innerTrackStyle]);
  const getThumbProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref: (0, import_react_utils3.mergeRefs)(ref, thumbRef),
    role: "slider",
    tabIndex: isInteractive ? 0 : void 0,
    id: thumbId,
    "data-active": (0, import_utils3.dataAttr)(isDragging),
    "aria-valuetext": valueText,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": value,
    "aria-orientation": orientation,
    "aria-disabled": (0, import_utils3.ariaAttr)(isDisabled),
    "aria-readonly": (0, import_utils3.ariaAttr)(isReadOnly),
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? void 0 : ariaLabelledBy,
    style: {
      ...props2.style,
      ...getThumbStyle(0)
    },
    onKeyDown: (0, import_utils3.callAllHandlers)(props2.onKeyDown, onKeyDown),
    onFocus: (0, import_utils3.callAllHandlers)(props2.onFocus, setFocused.on),
    onBlur: (0, import_utils3.callAllHandlers)(props2.onBlur, setFocused.off)
  }), [
    isInteractive,
    thumbId,
    isDragging,
    valueText,
    min,
    max,
    value,
    orientation,
    isDisabled,
    isReadOnly,
    ariaLabel,
    ariaLabelledBy,
    getThumbStyle,
    onKeyDown,
    setFocused.on,
    setFocused.off
  ]);
  const getMarkerProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => {
    const isInRange = !(props2.value < min || props2.value > max);
    const isHighlighted = value >= props2.value;
    const markerPercent = (0, import_utils3.valueToPercent)(props2.value, min, max);
    const markerStyle = {
      position: "absolute",
      pointerEvents: "none",
      ...orient2({
        orientation,
        vertical: {
          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        },
        horizontal: {
          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
        }
      })
    };
    return {
      ...props2,
      ref,
      role: "presentation",
      "aria-hidden": true,
      "data-disabled": (0, import_utils3.dataAttr)(isDisabled),
      "data-invalid": (0, import_utils3.dataAttr)(!isInRange),
      "data-highlighted": (0, import_utils3.dataAttr)(isHighlighted),
      style: {
        ...props2.style,
        ...markerStyle
      }
    };
  }, [isDisabled, isReversed, max, min, orientation, value]);
  const getInputProps = (0, import_react4.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    ref,
    type: "hidden",
    value,
    name
  }), [name, value]);
  return {
    state: {
      value,
      isFocused,
      isDragging
    },
    actions,
    getRootProps,
    getTrackProps,
    getInnerTrackProps,
    getThumbProps,
    getMarkerProps,
    getInputProps
  };
}
function orient2(options) {
  const { orientation, vertical, horizontal } = options;
  return orientation === "vertical" ? vertical : horizontal;
}
function getDefaultValue(min, max) {
  return max < min ? min : min + (max - min) / 2;
}

// src/slider.tsx
var [SliderProvider, useSliderContext] = (0, import_react_utils4.createContext)({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <Slider />"
});
var [SliderStylesProvider, useSliderStyles] = (0, import_react_utils4.createContext)({
  name: `SliderStylesContext`,
  errorMessage: `useSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Slider />" `
});
var Slider = (0, import_system2.forwardRef)((props, ref) => {
  const styles = (0, import_system2.useMultiStyleConfig)("Slider", props);
  const ownProps = (0, import_system2.omitThemingProps)(props);
  const { direction } = (0, import_system2.useTheme)();
  ownProps.direction = direction;
  const { getInputProps, getRootProps, ...context } = useSlider(ownProps);
  const rootProps = getRootProps();
  const inputProps = getInputProps({}, ref);
  return /* @__PURE__ */ import_react.default.createElement(SliderProvider, {
    value: context
  }, /* @__PURE__ */ import_react.default.createElement(SliderStylesProvider, {
    value: styles
  }, /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.div, {
    ...rootProps,
    className: (0, import_utils4.cx)("chakra-slider", props.className),
    __css: styles.container
  }, props.children, /* @__PURE__ */ import_react.default.createElement("input", {
    ...inputProps
  }))));
});
Slider.defaultProps = {
  orientation: "horizontal"
};
if (import_utils4.__DEV__) {
  Slider.displayName = "Slider";
}
var SliderThumb = (0, import_system2.forwardRef)((props, ref) => {
  const { getThumbProps } = useSliderContext();
  const styles = useSliderStyles();
  const thumbProps = getThumbProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.div, {
    ...thumbProps,
    className: (0, import_utils4.cx)("chakra-slider__thumb", props.className),
    __css: styles.thumb
  });
});
if (import_utils4.__DEV__) {
  SliderThumb.displayName = "SliderThumb";
}
var SliderTrack = (0, import_system2.forwardRef)((props, ref) => {
  const { getTrackProps } = useSliderContext();
  const styles = useSliderStyles();
  const trackProps = getTrackProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.div, {
    ...trackProps,
    className: (0, import_utils4.cx)("chakra-slider__track", props.className),
    __css: styles.track
  });
});
if (import_utils4.__DEV__) {
  SliderTrack.displayName = "SliderTrack";
}
var SliderFilledTrack = (0, import_system2.forwardRef)((props, ref) => {
  const { getInnerTrackProps } = useSliderContext();
  const styles = useSliderStyles();
  const trackProps = getInnerTrackProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.div, {
    ...trackProps,
    className: (0, import_utils4.cx)("chakra-slider__filled-track", props.className),
    __css: styles.filledTrack
  });
});
if (import_utils4.__DEV__) {
  SliderFilledTrack.displayName = "SliderFilledTrack";
}
var SliderMark = (0, import_system2.forwardRef)((props, ref) => {
  const { getMarkerProps } = useSliderContext();
  const markProps = getMarkerProps(props, ref);
  return /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.div, {
    ...markProps,
    className: (0, import_utils4.cx)("chakra-slider__marker", props.className)
  });
});
if (import_utils4.__DEV__) {
  SliderMark.displayName = "SliderMark";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RangeSlider,
  RangeSliderFilledTrack,
  RangeSliderMark,
  RangeSliderProvider,
  RangeSliderThumb,
  RangeSliderTrack,
  Slider,
  SliderFilledTrack,
  SliderMark,
  SliderProvider,
  SliderThumb,
  SliderTrack,
  useRangeSlider,
  useRangeSliderContext,
  useRangeSliderStyles,
  useSlider,
  useSliderContext,
  useSliderStyles
});
